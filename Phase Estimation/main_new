import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from tkinter import Tk
from tkinter.filedialog import askdirectory
import BiasAndSegmentation
from Interpolation import interpolate_and_visualize

# Function to select folder
def select_folder():
    Tk().withdraw()  # Close the root window
    folder_path = askdirectory(title="Select Folder")
    return folder_path

# Function to load and process files
def load_and_process_files(folder_path):
    acc_files = []
    gyro_files = []
    or_files = []

    # Iterate through files in the folder
    for file_name in os.listdir(folder_path):
        if "ACC_Profile" in file_name:
            acc_files.append(file_name)
        elif "GYRO_Profile" in file_name:
            gyro_files.append(file_name)
        elif "OR_Profile" in file_name and "OR_Debug_Profile" not in file_name:
            or_files.append(file_name)
    
    # Sort files
    acc_files.sort()
    gyro_files.sort()
    or_files.sort()
    
    # Load and process ACC files (and remove last 3 columns)
    acc_data = []
    for acc_file in acc_files:
        df = pd.read_csv(os.path.join(folder_path, acc_file))
        df = df.iloc[:, :-3]  # Remove last 3 columns
        acc_data.append(df)
    
    # Load GYRO files
    gyro_data = []
    for gyro_file in gyro_files:
        df = pd.read_csv(os.path.join(folder_path, gyro_file))
        gyro_data.append(df)
    
    # Load OR files
    or_data = []
    for or_file in or_files:
        df = pd.read_csv(os.path.join(folder_path, or_file))
        or_data.append(df)
    
    return acc_data, gyro_data, or_data, acc_files, gyro_files, or_files

# Function to extract timestamp from filename
def extract_timestamp(filename):
    parts = filename.split("_")
    for part in parts:
        if len(part) == 14 and part.isdigit():  # YYYYMMDDHHMMSS format
            return part
    return None

# Function to group files by timestamp
def group_files_by_timestamp(acc_files, gyro_files, or_files):
    grouped_indices = {}
    
    # Process ACC files
    for i, file_name in enumerate(acc_files):
        timestamp = extract_timestamp(file_name)
        if timestamp not in grouped_indices:
            grouped_indices[timestamp] = {"acc": None, "gyro": None, "or": None}
        grouped_indices[timestamp]["acc"] = i
    
    # Process GYRO files
    for i, file_name in enumerate(gyro_files):
        timestamp = extract_timestamp(file_name)
        if timestamp not in grouped_indices:
            grouped_indices[timestamp] = {"acc": None, "gyro": None, "or": None}
        grouped_indices[timestamp]["gyro"] = i
    
    # Process OR files
    for i, file_name in enumerate(or_files):
        timestamp = extract_timestamp(file_name)
        if timestamp not in grouped_indices:
            grouped_indices[timestamp] = {"acc": None, "gyro": None, "or": None}
        grouped_indices[timestamp]["or"] = i
    
    # Filter out incomplete groups
    complete_groups = {ts: indices for ts, indices in grouped_indices.items() 
                      if indices["acc"] is not None and indices["gyro"] is not None and indices["or"] is not None}
    
    return complete_groups


# Function to calculate time array
def calculate_time_array(gyro_interp, acc_interp, or_interp, frequencies):
    # This is a placeholder - replace with actual implementation
    print("Calculating time array...")
    return np.linspace(0, 1, len(gyro_interp))

# Function to create X and Y matrices
def create_matrices(acc_data, gyro_data, or_data, grouped_indices):
    X = []
    Y = []
    segment_lengths = []
    feature_names = []
    
    # Sort timestamps to ensure chronological order
    sorted_timestamps = sorted(grouped_indices.keys())
    executed = False
    for timestamp in sorted_timestamps:
        indices = grouped_indices[timestamp]
        
        # Get the data for this timestamp
        acc = acc_data[indices["acc"]]
        gyro = gyro_data[indices["gyro"]]
        or_data_item = or_data[indices["or"]]
        
        print(f"Processing data set from timestamp: {timestamp}")
        
        if not executed:
            frequencies = BiasAndSegmentation.sensors_frequencies()
        executed = True

        # Apply the segmentation and bias correction
        gyro_processed, acc_processed, or_processed, *_ = BiasAndSegmentation.segmentation_and_bias(
            gyro, acc, or_data_item, frequencies, plot_flag=False
        )
        
        # Apply interpolation
        gyro_interp, acc_interp, or_interp = interpolate_and_visualize(
            gyro_processed, acc_processed, or_processed, 
            frequencies, plot_flag=False
        )
        
        # Concatenate features for X matrix
        features = np.concatenate([acc_interp.values, gyro_interp.values, or_interp.values], axis=1)
        X.append(features)
        
        # Create Y matrix segment (going from 0 to 1 for the duration of this dataset)
        dataset_length = len(features)
        y = np.linspace(0, 1, dataset_length)
        Y.append(y)
        
        segment_lengths.append(dataset_length)
        
        # Store feature names (first time only)
        if not feature_names:
            acc_cols = [f"ACC_{col}" for col in acc_interp.columns]
            gyro_cols = [f"GYRO_{col}" for col in gyro_interp.columns]
            or_cols = [f"OR_{col}" for col in or_interp.columns]
            feature_names = acc_cols + gyro_cols + or_cols
    
    # Stack X matrices vertically
    X_matrix = np.vstack(X)
    
    # Concatenate Y segments
    Y_matrix = np.concatenate(Y)
    
    return X_matrix, Y_matrix, sorted_timestamps, segment_lengths, feature_names

# Function to visualize X and Y matrices
def visualize_matrices(X, Y, timestamps, segment_lengths, feature_names):
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 10), sharex=True)
    
    # Create separate axes for different sensor types
    ax1_acc = ax1.twinx()
    ax1_or = ax1.twinx()
    
    # Offset the right spine of ax1_or
    ax1_or.spines['right'].set_position(('outward', 60))
    
    # Set different colors for different sensor types
    acc_color = 'red'
    gyro_color = 'blue'
    or_color = 'green'
    
    time_steps = np.arange(X.shape[0])
    
    # Plot concatenated signals with different scales
    for i, name in enumerate(feature_names):
        if 'ACC' in name:
            ax1_acc.plot(time_steps, X[:, i], color=acc_color, alpha=0.7, linewidth=0.8)
        elif 'GYRO' in name:
            ax1.plot(time_steps, X[:, i], color=gyro_color, alpha=0.7, linewidth=0.8)
        elif 'OR' in name:
            ax1_or.plot(time_steps, X[:, i], color=or_color, alpha=0.7, linewidth=0.8)
    
    # Set labels and legend
    ax1.set_title("Concatenated Sensor Signals")
    ax1.set_ylabel("Gyroscope Values", color=gyro_color)
    ax1_acc.set_ylabel("Accelerometer Values", color=acc_color)
    ax1_or.set_ylabel("Orientation Values", color=or_color)
    
    # Set tick colors
    ax1.tick_params(axis='y', labelcolor=gyro_color)
    ax1_acc.tick_params(axis='y', labelcolor=acc_color)
    ax1_or.tick_params(axis='y', labelcolor=or_color)
    
    # Create custom legend
    from matplotlib.lines import Line2D
    legend_elements = [
        Line2D([0], [0], color=gyro_color, lw=2, label='Gyroscope'),
        Line2D([0], [0], color=acc_color, lw=2, label='Accelerometer'),
        Line2D([0], [0], color=or_color, lw=2, label='Orientation')
    ]
    ax1.legend(handles=legend_elements, loc='upper right')
    
    # Add grid
    ax1.grid(True)
    
    # Plot progress indicators (Y matrix)
    current_pos = 0
    for ts, length in zip(timestamps, segment_lengths):
        segment_range = np.arange(current_pos, current_pos + length)
        segment_values = np.linspace(0, 1, length)
        ax2.plot(segment_range, segment_values, label=f"Segment {ts}")
        current_pos += length
    
    ax2.set_title("Dataset Progress Indicators (0 to 1)")
    ax2.set_xlabel("Time Steps")
    ax2.set_ylabel("Progress")
    ax2.grid(True)
    
    # Add vertical lines to separate different datasets
    current_pos = 0
    for ts, length in zip(timestamps, segment_lengths):
        current_pos += length
        
        if current_pos < X.shape[0]:  # Don't draw a line after the last dataset
            ax1.axvline(x=current_pos, color='r', linestyle='--', alpha=0.5)
            ax2.axvline(x=current_pos, color='r', linestyle='--', alpha=0.5)
    
    plt.tight_layout()
    plt.show()

# Main script
def main():
    # Select folder
    folder_path = select_folder()
    
    if not folder_path:
        print("No folder selected. Exiting...")
        return
    
    print(f"Selected folder: {folder_path}")
    
    try:
        # Load and process files
        acc_data, gyro_data, or_data, acc_files, gyro_files, or_files = load_and_process_files(folder_path)
        
        print(f"Loaded {len(acc_files)} ACC files, {len(gyro_files)} GYRO files, and {len(or_files)} OR files")
        
        # Group files by timestamp
        grouped_indices = group_files_by_timestamp(acc_files, gyro_files, or_files)
        
        print(f"Found {len(grouped_indices)} complete data sets")
        
        if not grouped_indices:
            print("No complete data sets found. Exiting...")
            return
        
        # Create X and Y matrices
        X, Y, timestamps, segment_lengths, feature_names = create_matrices(acc_data, gyro_data, or_data, grouped_indices)
        
        print(f"Created X matrix with shape {X.shape} and Y matrix with length {len(Y)}")
        
        
        # Print column information
        print("\nColumn information:")
        for i, name in enumerate(feature_names):
            print(f"Column {i}: {name}")
        
        # Visualize matrices
        visualize_matrices(X, Y, timestamps, segment_lengths, feature_names)
        
        plt.show(block=True)
        
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()
